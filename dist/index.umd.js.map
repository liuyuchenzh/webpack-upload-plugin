{"version":3,"file":"index.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../util/io.mjs","../util/regexp.mjs","../util/status.mjs","../util/static.mjs","../util/log.mjs","../util/util.mjs","../index.mjs"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = (function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\treturn this;\n\t};\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import fs from 'fs'\n// read file\nexport const read = location => fs.readFileSync(location, 'utf-8')\n// write file\nexport const write = location => content => fs.writeFileSync(location, content)\n","export const getPublicPathExp = () => /__webpack_require__\\.p\\s?=\\s?([^;]+);/g\nexport const getScriptRegExp = () =>\n  /__webpack_require__\\.p\\s?\\+[^[]+\\[(\\S+)][^\\n]+?\\.js['\"];?/g\nexport const getCssChunksRegExp = () => /var\\scssChunks\\s*=\\s*([^;\\n]+);/\nexport const getCssHrefRegExp = () => /var\\shref\\s*=[^\\n]+?chunkId[^\\n;]+;/\n","import fs from 'fs'\nimport path from 'path'\nexport function isFile(input) {\n  return fs.statSync(input).isFile()\n}\n\nexport function isDir(input) {\n  return fs.statSync(input).isDirectory()\n}\n\nexport function isType(type) {\n  return function enterFile(file) {\n    return isFile(file) && path.extname(file) === '.' + type\n  }\n}\n","export const name = 'webpack-upload-plugin'\n","import { name as pjName } from './static.mjs'\n\n/**\n * log information\n * @param {*} msg\n */\nexport function log(msg) {\n  console.log(`[${pjName}]: ${msg}`)\n}\n\n/**\n * log error\n * @param msg\n */\nexport function logErr(msg) {\n  console.error(`[${pjName}]: ${msg}`)\n}\n","import path from 'path'\nimport fs from 'fs'\nimport fse from 'fs-extra'\nimport { read, write } from './io.mjs'\nimport {\n  getCssChunksRegExp,\n  getCssHrefRegExp,\n  getScriptRegExp,\n  getPublicPathExp\n} from './regexp.mjs'\nimport { isFile, isDir, isType } from './status.mjs'\nimport { logErr } from './log.mjs'\nimport { name as pjName } from './static.mjs'\n\nconst DEFAULT_SEP = '/'\nconst FILTER_OUT_DIR = ['.idea', '.vscode', '.gitignore', 'node_modules']\n\n// 1. gather html file\n// 2. gather production file\n// 3. upload all production file\n// 4. find the usage of production file in html file\n// 5. if found, replace\n\n// type related\nconst imgTypeArr = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'ico']\nconst fontTypeArr = ['woff', 'woff2', 'ttf', 'oft', 'svg', 'eot']\nconst isCss = isType('css')\nconst isJs = isType('js')\nconst isOneOfType = (types = ['']) => file =>\n  types.some(type => isType(type)(file))\n\nfunction isFont(path) {\n  return fontTypeArr.some(type => isType(type)(path))\n}\n\nfunction isImg(path) {\n  return imgTypeArr.some(type => isType(type)(path))\n}\n\n/**\n *\n * @param {string[]} input\n * @return {string}\n */\nfunction resolve(...input) {\n  return path.resolve(...input)\n}\n\n/**\n * @param {string} input\n * @param {string=} [sep=DEFAULT_SEP]\n * @return {string}\n */\nfunction normalize(input, sep = DEFAULT_SEP) {\n  const _input = path.normalize(input)\n  return _input.split(path.sep).join(sep)\n}\n\n/**\n * @param {string} input\n * @return {boolean}\n */\nfunction isFilterOutDir(input) {\n  return FILTER_OUT_DIR.includes(input)\n}\n\n/**\n * remove publicPath from webpack config\n * @param {string} publicPath\n * @return {function(string): string}\n */\nconst handlePublicPath = publicPath => content => {\n  // match strictly\n  const regStr = publicPath\n    .split(DEFAULT_SEP)\n    .filter(item => !!item)\n    .map(part => {\n      if (/\\./.test(part)) {\n        return part.replace(/\\.+/g, match =>\n          match\n            .split('')\n            .map(dot => '\\\\' + dot)\n            .join('')\n        )\n      }\n      return part\n    })\n    .join('\\\\/')\n  const refinedRegStr = `([(=]['\"]?)${regStr}`\n  const reg = new RegExp(refinedRegStr, 'g')\n  return content.replace(reg, (_, prefix) => (prefix ? prefix : ''))\n}\n\n/**\n * given localPath, return string to form matching RegExp\n * @param {string} localPath\n * @returns {string}\n */\nfunction generateLocalPathStr(localPath) {\n  const pathArr = localPath.split(DEFAULT_SEP)\n  const len = pathArr.length\n  return pathArr\n    .map((part, index) => {\n      if (index === len - 1) {\n        return `${part}`\n      } else {\n        return `\\\\.?(${part})?`\n      }\n    })\n    .join(`\\\\${DEFAULT_SEP}?`)\n}\n\n/**\n * produce RegExp to match local path\n * @param {string} localPath\n * @return {RegExp}\n */\nfunction generateLocalPathReg(localPath) {\n  const content = generateLocalPathStr(localPath)\n  const prefix = `([(=+]\\\\s*['\"]?)`\n  // using prefix to strictly match resource reference\n  // like src=\"\", url(\"\"), a = \"\"\n  return new RegExp(`${prefix}${content}`, 'g')\n}\n\n/**\n * find file usage\n * 1. make sure the range: srcPath\n * 2. provide inline path to search and to replace with: localCdnPair\n * @param {string} srcPath\n * @param {string=} distPath\n * @param {function=} replaceFn\n * @param {boolean=} [copyWhenUntouched=true] copy file even if the content remains the same\n * @return {function}\n */\nfunction simpleReplace(\n  srcPath,\n  distPath = srcPath,\n  replaceFn = input => input,\n  copyWhenUntouched = true\n) {\n  const srcFile = read(srcPath)\n  return function savePair(localCdnPair) {\n    const ret = localCdnPair.reduce((last, file) => {\n      const localPath = normalize(file[0])\n      const cdnPath = file[1]\n      const localPathReg = generateLocalPathReg(localPath)\n      last = replaceFn(last, srcPath).replace(\n        localPathReg,\n        (_, prefix) => `${prefix}${cdnPath}`\n      )\n      return last\n    }, srcFile)\n    // no such path > force copy > content change\n    const toCopy =\n      !fs.existsSync(distPath) || copyWhenUntouched || ret !== srcFile\n    if (toCopy) {\n      fse.ensureFileSync(distPath)\n      write(distPath)(ret)\n    }\n  }\n}\n\n/**\n * gather specific file type within directory provided\n * 1. provide range to search: src\n * 2. provide the type of file to search: type\n * @param {string} src: directory to search\n * @return {function}\n */\nfunction gatherFileIn(src) {\n  return function gatherFileType(type) {\n    return fs.readdirSync(src).reduce((last, file) => {\n      const filePath = resolve(src, file)\n      if (isFile(filePath)) {\n        path.extname(file) === `.${type}` && last.push(normalize(filePath))\n      } else if (isFilterOutDir(file)) {\n        // do nothing\n      } else if (isDir(filePath)) {\n        last = last.concat(gatherFileIn(filePath)(type))\n      }\n      return last\n    }, [])\n  }\n}\n\n/**\n * make sure urlCb is applied for all cdn results\n * @param {function(string): string} cb\n * @return {function(string[]|{[string]:string}):[string, string][]}\n */\nconst handleCdnRes = cb => entries => {\n  if (typeof cb !== 'function') return logErr(`urlCb is not function`)\n  const isArr = Array.isArray(entries)\n  // if not array, handle as {[localLocation]: [cdnUrl]}\n  const target = isArr ? entries : Object.entries(entries)\n  return target.map(pair => {\n    // pair[1] should be cdn url\n    // pass local path as well\n    pair[1] = cb(pair[1], pair[0])\n    if (typeof pair[1] !== 'string')\n      logErr(`the return result of urlCb is not string`)\n    return pair\n  })\n}\n\n/**\n * given file path, src root and dist root, return file path in dist root\n * @param {string} srcFilePath\n * @param {string} srcRoot\n * @param {string} distRoot\n * @return {string}\n */\nfunction mapSrcToDist(srcFilePath, srcRoot, distRoot) {\n  return srcFilePath.replace(srcRoot, distRoot)\n}\n\n/**\n * generate {id: name} object for all chunk chunk\n * @param {{id: string, name:string,renderedHash: string, contentHash: string}[]} chunks\n * @param {string} chunkFileName\n */\nfunction gatherChunks(chunks, chunkFileName) {\n  return chunks.reduce((last, chunk) => {\n    if (/\\[hash(:\\d+)?]/.test(chunkFileName)) {\n      throw new Error(\n        `[${pjName}]: Do NOT use [hash] as output filename! Use [chunkhash] or [contenthash] instead`\n      )\n    }\n    const { id, name, renderedHash, contentHash } = chunk\n    // handle slice properly\n    const handleLen = source => (match, len) => {\n      if (len) {\n        return source.slice(0, +len.slice(1))\n      }\n      return source\n    }\n    const handleChunkHash = handleLen(renderedHash)\n    // handle webpack@4 as well as <4\n    const handleContentHash = handleLen(\n      contentHash ? contentHash.javascript : renderedHash\n    )\n    last[id] = chunkFileName\n      .replace(/\\[name]/g, name || `${id}`)\n      .replace(/\\[id]/g, `${id}`)\n      .replace(/\\[chunkhash(:\\d+)?]/g, handleChunkHash)\n      .replace(/\\[contenthash(:\\d+)?]/g, handleContentHash)\n    return last\n  }, {})\n}\n\n/**\n * whether chunk is \"entry\" (common chunks is also considered as \"entry\")\n * @param {string} js\n * @returns {boolean}\n */\nfunction isEntryChunk(js) {\n  const content = read(js)\n  return getScriptRegExp().test(content)\n}\n\n/**\n * convert object to array\n * @param {object} obj\n * @returns {*[]}\n */\nfunction getObjValueArray(obj) {\n  return Object.values(obj)\n}\n\n/**\n * update script.src property for request for dynamic import\n * experimental\n * @param {string[]} files\n * @param {{id: string}} chunkCdnMap\n */\nfunction updateScriptSrc(files, chunkCdnMap) {\n  // if no new map was formed, then keep the way it is\n  const len = Object.keys(chunkCdnMap).length\n  if (!len) return\n  files.forEach(file => {\n    const content = read(file)\n    let newContent = content\n    // update chunkMap\n    if (getScriptRegExp().test(content)) {\n      newContent = newContent.replace(getScriptRegExp(), (match, id) => {\n        if (!id) {\n          return match\n        }\n        return `${JSON.stringify(chunkCdnMap)}[${id}];`\n      })\n    }\n    // update publicPath\n    if (getPublicPathExp().test(content)) {\n      newContent = newContent.replace(\n        getPublicPathExp(),\n        `__webpack_require__.p = \"\";`\n      )\n    }\n    write(file)(newContent)\n  })\n}\n\n/**\n * Handle async CSS files extracted by mini-css-extract-plugin\n * @param {string[]} chunkFiles\n * @param {[string, string][]} cssMap\n * @param {string} publicPath\n */\nfunction updateCssLoad(chunkFiles, cssMap, publicPath) {\n  const keys = cssMap.map(([local]) => local)\n  chunkFiles.forEach(file => {\n    const content = read(file)\n    let newContent = content\n    const match = content.match(getCssChunksRegExp())\n    if (match) {\n      const [, map] = match\n      newContent = newContent.replace(getCssHrefRegExp(), hrefMatch => {\n        // get the new cssMap with {chunkId, href} structure\n        // where chunkId is the id for the css file, and href is the cdn url\n        const fnBody = `\n            const map = ${map};\n            return Object.keys(map).map(chunkId => {\n              ${hrefMatch};\n              const newHref = href.replace(/^\\\\./, \"\");\n              return {chunkId, href: newHref, rawHref: href};\n            })\n          `\n        const hrefArr = new Function(fnBody)()\n        // convert to {[chunkId]: href} structure\n        const cssChunkIdCdnMap = hrefArr.reduce(\n          (last, { chunkId, href, rawHref }) => {\n            const localIndex = keys.findIndex(key => key.indexOf(href) > -1)\n            if (localIndex < 0) {\n              // use the original href when not found from cdn result\n              // since __webpack_require__.p will be set to \"\"\n              // publicPath is added here\n              // reason: var fullhref = __webpack_require__.p + href;\n              last[chunkId] = publicPath + rawHref\n              return last\n            }\n            last[chunkId] = cssMap[localIndex][1]\n            return last\n          },\n          {}\n        )\n        // cannot form new Map, return the original one\n        if (!Object.keys(cssChunkIdCdnMap).length) {\n          return hrefMatch\n        }\n        const newCssMap = JSON.stringify(cssChunkIdCdnMap)\n        return `var href = ${newCssMap}[chunkId];`\n      })\n      // update js entry file with new cssMap\n      write(file)(newContent)\n    }\n  })\n}\n\n/**\n * get id of chunk given a absolute path of chunk file and id:chunk map\n * @param {string} chunkAbsPath\n * @param {{id: string}} chunkMap\n * @returns {string|number}\n */\nfunction getIdForChunk(chunkAbsPath, chunkMap) {\n  return Object.keys(chunkMap).find(\n    key => chunkAbsPath.indexOf(chunkMap[key]) > -1\n  )\n}\n\n/**\n * make assets object to array with local path\n * @param {{[string]: {existsAt: string}}} asset\n * @returns {string[]}\n */\nfunction getExistsAtFromAsset(asset) {\n  return Object.keys(asset).map(name => {\n    const info = asset[name]\n    return info.existsAt\n  })\n}\n\nexport {\n  resolve,\n  simpleReplace,\n  handlePublicPath,\n  updateScriptSrc,\n  updateCssLoad,\n  isEntryChunk,\n  getIdForChunk,\n  gatherChunks,\n  getObjValueArray,\n  handleCdnRes,\n  mapSrcToDist,\n  gatherFileIn,\n  isJs,\n  isCss,\n  isImg,\n  isFont,\n  isOneOfType,\n  imgTypeArr,\n  fontTypeArr,\n  getExistsAtFromAsset\n}\n","import path from 'path'\nimport {\n  parallel,\n  compatCache,\n  beforeUpload as beforeProcess\n} from 'y-upload-utils'\nimport {\n  resolve,\n  simpleReplace,\n  handlePublicPath,\n  getExistsAtFromAsset,\n  handleCdnRes,\n  isCss,\n  isEntryChunk,\n  isFont,\n  isImg,\n  isJs,\n  isOneOfType,\n  imgTypeArr,\n  fontTypeArr,\n  gatherChunks,\n  gatherFileIn,\n  getIdForChunk,\n  mapSrcToDist,\n  getObjValueArray,\n  updateCssLoad,\n  updateScriptSrc\n} from './util/util.mjs'\nimport { log, logErr } from './util/log.mjs'\n\n/**\n * @typedef {function(string): string} urlCb\n */\n\n/**\n * webpack upload plugin\n * early version need more work\n * @param {{upload: Promise}} cdn\n * custom cdn module, need to have an upload API, return a Promise with structured response\n * like {localPath: cdnPath}\n * @param {object} option\n * @param {string=} option.src\n * @param {string=} option.dist\n * @param {(function(string, string=) => string)=} option.urlCb\n * @param {function=} option.onFinish\n * @param {(function(string, string=) => string)=} option.replaceFn\n * @param {(function(string, string) => string)=} option.beforeUpload\n * @param {(string|string[])=} option.staticDir\n * @param {(function() => Promise<*>)=} option.waitFor\n * @param {boolean=} [option.dirtyCheck=false]\n * @param {boolean=} option.logLocalFiles\n * @param {object=} option.passToCdn\n * @param {boolean=} [option.enableCache=true]\n * @param {string=} option.cacheLocation\n * @param {number=} [option.sliceLimit=10]\n * @param {boolean=} option.forceCopyTemplate\n * @param {boolean=} [option.asyncCSS=true]\n * @param {boolean=} [option.smartAssMode=false]\n * @constructor\n */\nfunction UploadPlugin(cdn, option = {}) {\n  this.cdn = cdn\n  this.option = option\n}\n\nUploadPlugin.prototype.apply = function(compiler) {\n  const self = this\n  const {\n    urlCb = input => input,\n    resolve: resolveList = ['html'],\n    src = '',\n    dist = src,\n    onFinish = () => {},\n    onError = () => {},\n    logLocalFiles: logLocal = false,\n    staticDir = '',\n    replaceFn = input => input,\n    beforeUpload,\n    waitFor = () => Promise.resolve(true),\n    dirtyCheck = false,\n    passToCdn,\n    enableCache = true,\n    cacheLocation,\n    sliceLimit,\n    forceCopyTemplate,\n    asyncCSS = true,\n    smartAssMode = false\n  } = this.option\n  // get absolute path of src and dist directory\n  let srcRoot = resolve(src)\n  let distRoot = resolve(dist)\n  let staticDirMut = staticDir\n  let srcMut = src\n  const getLocal2CdnObj = handleCdnRes(urlCb)\n  const isTemplate = isOneOfType(resolveList)\n\n  /**\n   * update chunkMap to {[id: string|number]: cdnUrl}\n   * @param {{[localPath: string]: string}} chunkPairs\n   * @param {{[id: string|number]: string}} chunkMap\n   * @param {*} start\n   */\n  function generateChunkMapToCDN(chunkPairs, chunkMap, start = {}) {\n    return getLocal2CdnObj(chunkPairs).reduce((last, [localPath, cdnPath]) => {\n      const id = getIdForChunk(localPath, chunkMap)\n      last[id] = cdnPath\n      return last\n    }, start)\n  }\n\n  // wrap a new cdn object\n  const rawCdn = {\n    upload(files) {\n      return self.cdn.upload(files, passToCdn)\n    }\n  }\n\n  // log error for cache setup\n  if (!enableCache && cacheLocation) {\n    logErr(`'cacheLocation' provided while haven't set 'enableCache' to true`)\n    logErr(`This won't enable cache`)\n  }\n\n  // wrap with parallel\n  const paralleledCdn = parallel(rawCdn, { sliceLimit })\n\n  // wrap with cache\n  const wrappedCdn = enableCache\n    ? compatCache(paralleledCdn, {\n        passToCdn,\n        cacheLocation\n      })\n    : paralleledCdn\n\n  // wrap with beforeProcess\n  // use beforeUpload properly\n  const cdn = beforeProcess(wrappedCdn, beforeUpload)\n\n  compiler.plugin('done', async function(stats) {\n    try {\n      // wait to handle extra logic\n      await waitFor()\n      const { chunks, options } = stats.compilation\n      const {\n        output: { publicPath = '', path: outputPath },\n        optimization: { minimize, runtimeChunk } = {}\n      } = options\n      // early warning\n      if (minimize === true) {\n        log('WARNING! Set the optimization.minimize to false to make it works!')\n      }\n      if (publicPath) {\n        log(\n          'WARNING! publicPath is not empty, the plugin will try to handle it for you. But it is preferred to toggle it by yourself!'\n        )\n      }\n      // try to be smart ass\n      // which means assume all needed files is in the output.path from webpack\n      if (smartAssMode) {\n        srcRoot = outputPath\n        distRoot = outputPath\n        staticDirMut = outputPath\n        srcMut = outputPath\n      }\n      // don't want to use publicPath since about to use cdn url\n      const removePublicPath = handlePublicPath(publicPath)\n      // actual replaceFn that gonna be used\n      const refinedReplaceFn = (content, location) => {\n        const type = path.extname(location)\n        // only remove publicPath occurrence for css/template files\n        // it's tricky to handle js files\n        const removePublicPathTypes = ['.css', ...resolveList.map(t => `.${t}`)]\n        const toRemove = removePublicPathTypes.includes(type)\n        return replaceFn(\n          toRemove ? removePublicPath(content) : content,\n          location\n        )\n      }\n      // if user offers staticDir\n      // then only collect files from staticDir\n      // instead of ones provided by webpack\n      // if pass in an array, gather files recursively\n      const gatherManualAssets = Array.isArray(staticDirMut)\n        ? type => {\n            return staticDirMut.reduce((last, dir) => {\n              return [...last, ...gatherFileIn(dir)(type)]\n            }, [])\n          }\n        : gatherFileIn(staticDirMut)\n      const manualAssets = staticDirMut\n        ? [...imgTypeArr, ...fontTypeArr, 'css', 'js', ...resolveList].reduce(\n            (last, type) => {\n              const files = gatherManualAssets(type)\n              return files.reduce((fileLast, file) => {\n                return Object.assign(fileLast, {\n                  [file]: {\n                    existsAt: file\n                  }\n                })\n              }, last)\n            },\n            {}\n          )\n        : {}\n      // here we get chunks needs to be dealt with\n      const chunkMap = gatherChunks(chunks, options.output.chunkFilename)\n      // all assets including js/css/img\n      const { assets } = staticDirMut\n        ? { assets: manualAssets }\n        : stats.compilation\n      const assetsNames = Object.keys(assets)\n      // classify assets\n      const desireAssets = assetsNames.reduce(\n        (last, name) => {\n          const assetInfo = assets[name]\n          const location = assetInfo.existsAt\n          if (isImg(location)) {\n            last.img[name] = assetInfo\n          } else if (isCss(location)) {\n            last.css[name] = assetInfo\n          } else if (isJs(location)) {\n            last.js[name] = assetInfo\n          } else if (isFont(location)) {\n            last.font[name] = assetInfo\n          } else if (isTemplate(location)) {\n            last.html[name] = assetInfo\n          }\n          return last\n        },\n        {\n          img: {},\n          css: {},\n          js: {},\n          font: {},\n          html: {}\n        }\n      )\n\n      const { img, css, js, font, html } = desireAssets\n\n      // warning if no template found but staticDirMut set\n      if (staticDirMut && !Object.keys(html).length && !src) {\n        log('WARNING!')\n        log(\n          \"staticDir is set but haven't found any template files in those directories\"\n        )\n        log('Try to use src filed to include your template files')\n      }\n\n      const imgArr = getExistsAtFromAsset(img)\n      const fontArr = getExistsAtFromAsset(font)\n      const jsArr = getExistsAtFromAsset(js)\n      const cssArr = getExistsAtFromAsset(css)\n      const htmlArr = getExistsAtFromAsset(html)\n      const chunkArr = getObjValueArray(chunkMap)\n      const commonChunksArr = jsArr.filter(isEntryChunk)\n      // if provide with src\n      // then use it\n      // or use emitted html files\n      const tplFiles = !srcMut\n        ? htmlArr\n        : resolveList.reduce((last, type) => {\n            const findFileInRoot = gatherFileIn(srcMut)\n            last = last.concat(findFileInRoot(type))\n            return last\n          }, [])\n\n      // find out which js files are chunk chunk, common chunk, or entry\n      const { notChunkJsArr, chunkArrWAbs, commonChunksWAbs } = jsArr.reduce(\n        (last, js) => {\n          const isCommonChunk = commonChunksArr.some(\n            chunk => js.indexOf(chunk) > -1\n          )\n          const isChunk =\n            !isCommonChunk && chunkArr.some(chunk => js.indexOf(chunk) > -1)\n          if (isCommonChunk) {\n            last.commonChunksWAbs.push(js)\n          } else if (isChunk) {\n            last.chunkArrWAbs.push(js)\n          } else {\n            last.notChunkJsArr.push(js)\n          }\n          return last\n        },\n        {\n          notChunkJsArr: [],\n          chunkArrWAbs: [],\n          commonChunksWAbs: []\n        }\n      )\n\n      if (notChunkJsArr.length) {\n        // nothing\n      }\n\n      // upload img/font\n      // find img/font in css\n      // replace css\n      // now css ref to img/font with cdn path\n      // meanwhile upload chunk files to save time\n      log('uploading img and font...')\n      logLocal && console.log([...imgArr, ...fontArr])\n      const imgAndFontPairs = await cdn.upload([...imgArr, ...fontArr])\n      // update img/font reference in css/js files\n      // including chunk files\n      log('update css/js files with new img and font...')\n      const needToUpdateFiles = [...jsArr, ...cssArr]\n      needToUpdateFiles.forEach(location =>\n        simpleReplace(location, location, refinedReplaceFn)(\n          getLocal2CdnObj(imgAndFontPairs)\n        )\n      )\n      // upload chunk files\n      log('uploading chunks...')\n      logLocal && console.log(chunkArrWAbs)\n      const chunkPairs = await cdn.upload(chunkArrWAbs)\n      // update chunkMap, so far no cdn url for common chunks\n      let newChunkMap = generateChunkMapToCDN(chunkPairs, chunkMap, {})\n      log('uploading css...')\n      logLocal && console.log(cssArr)\n      const cssLocal2CdnObj = await cdn.upload(cssArr)\n      // handle async css files\n      if (asyncCSS) {\n        updateCssLoad(\n          commonChunksWAbs,\n          getLocal2CdnObj(cssLocal2CdnObj),\n          publicPath\n        )\n      }\n      // entry chunk is just entry file : )\n      // the reason uploading common as well as entry is to support webpack@4 and < 4\n      // have common/entry chunks, update chunkMap within it\n      // upload them, so their cdn url can be added to newChunkMap\n      // then entries can be updated with newChunkMap that has cdn url for common chunks\n      let commonChunksPair = {}\n      // having runtimeChunk means entry js is likely inlined\n      // therefore template files need to be checked for chunkMap existence\n      const isEntryInline = !!runtimeChunk\n      const entryTplList = isEntryInline ? tplFiles.filter(isEntryChunk) : []\n      const entryList = [...commonChunksWAbs, ...entryTplList]\n      if (entryList.length) {\n        updateScriptSrc(entryList, newChunkMap)\n        if (commonChunksWAbs.length) {\n          log('upload common/entry chunks...')\n          commonChunksPair = await cdn.upload(commonChunksWAbs)\n          newChunkMap = generateChunkMapToCDN(\n            commonChunksPair,\n            chunkMap,\n            newChunkMap\n          )\n        }\n      }\n      // if use dirty check, then check all js files for chunkMap\n      // since webpack@4, every js is chunk\n      // so only filter out common/entry chunks since they should be updated\n      // and uploaded right above\n      const manifestList = dirtyCheck\n        ? jsArr\n        : jsArr.filter(js => !commonChunksWAbs.includes(js))\n      updateScriptSrc(manifestList, newChunkMap)\n\n      // only js here\n      const adjustedFiles = [...manifestList]\n\n      log('uploading js...')\n      logLocal && console.log(adjustedFiles)\n      const jsLocal2CdnObj = await cdn.upload(adjustedFiles)\n      // reuse image/common chunks result here\n      // ! important to reuse common chunks since they could just by entry files\n      const allLocal2CdnObj = Object.assign(\n        jsLocal2CdnObj,\n        cssLocal2CdnObj,\n        imgAndFontPairs,\n        commonChunksPair\n      )\n      tplFiles.forEach(filePath => {\n        simpleReplace(\n          filePath,\n          mapSrcToDist(filePath, srcRoot, distRoot),\n          refinedReplaceFn,\n          forceCopyTemplate\n        )(getLocal2CdnObj(allLocal2CdnObj))\n      })\n      // run onFinish if it is a valid function\n      onFinish()\n      log('all done')\n    } catch (e) {\n      log('err occurred!')\n      console.log(e)\n      // run when encounter error\n      onError(e)\n    }\n  })\n}\n\nmodule.exports = UploadPlugin\n"],"names":["const","read","location","fs","readFileSync","write","content","writeFileSync","getPublicPathExp","getScriptRegExp","getCssChunksRegExp","getCssHrefRegExp","isFile","input","statSync","isDir","isDirectory","isType","type","enterFile","file","path","extname","name","log","msg","console","pjName","logErr","error","DEFAULT_SEP","FILTER_OUT_DIR","imgTypeArr","fontTypeArr","isCss","isJs","isOneOfType","types","some","isFont","isImg","resolve","normalize","sep","_input","split","join","isFilterOutDir","includes","handlePublicPath","publicPath","regStr","filter","item","map","part","test","replace","match","dot","refinedRegStr","reg","RegExp","_","prefix","generateLocalPathStr","localPath","pathArr","len","length","index","generateLocalPathReg","simpleReplace","srcPath","distPath","replaceFn","copyWhenUntouched","srcFile","savePair","localCdnPair","ret","reduce","last","cdnPath","localPathReg","toCopy","existsSync","fse","ensureFileSync","gatherFileIn","src","gatherFileType","readdirSync","filePath","push","concat","handleCdnRes","cb","entries","isArr","Array","isArray","target","Object","pair","mapSrcToDist","srcFilePath","srcRoot","distRoot","gatherChunks","chunks","chunkFileName","chunk","Error","renderedHash","contentHash","handleLen","source","slice","handleChunkHash","handleContentHash","javascript","id","isEntryChunk","js","getObjValueArray","obj","values","updateScriptSrc","files","chunkCdnMap","keys","forEach","newContent","JSON","stringify","updateCssLoad","chunkFiles","cssMap","local","hrefMatch","fnBody","hrefArr","Function","cssChunkIdCdnMap","href","rawHref","localIndex","findIndex","key","indexOf","chunkId","newCssMap","getIdForChunk","chunkAbsPath","chunkMap","find","getExistsAtFromAsset","asset","info","existsAt","UploadPlugin","cdn","option","prototype","apply","compiler","self","beforeUpload","Promise","passToCdn","cacheLocation","sliceLimit","forceCopyTemplate","dist","staticDirMut","staticDir","srcMut","getLocal2CdnObj","urlCb","isTemplate","resolveList","generateChunkMapToCDN","chunkPairs","start","rawCdn","upload","enableCache","paralleledCdn","parallel","wrappedCdn","compatCache","beforeProcess","plugin","stats","waitFor","compilation","options","outputPath","minimize","runtimeChunk","smartAssMode","removePublicPath","refinedReplaceFn","removePublicPathTypes","t","toRemove","gatherManualAssets","dir","manualAssets","fileLast","assign","output","chunkFilename","assets","assetsNames","desireAssets","assetInfo","img","css","font","html","imgArr","fontArr","jsArr","cssArr","htmlArr","chunkArr","commonChunksArr","tplFiles","findFileInRoot","isCommonChunk","isChunk","commonChunksWAbs","chunkArrWAbs","notChunkJsArr","logLocal","imgAndFontPairs","needToUpdateFiles","newChunkMap","cssLocal2CdnObj","manifestList","dirtyCheck","adjustedFiles","jsLocal2CdnObj","allLocal2CdnObj","commonChunksPair","onFinish","asyncCSS","isEntryInline","entryTplList","entryList","e","onError","module","exports"],"mappings":"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"}