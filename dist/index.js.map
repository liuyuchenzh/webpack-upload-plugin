{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../util/io.mjs","../util/regexp.mjs","../util/status.mjs","../util/static.mjs","../util/log.mjs","../util/util.mjs","../index.mjs"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = (function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\treturn this;\n\t};\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import fs from 'fs'\n// read file\nexport const read = location => fs.readFileSync(location, 'utf-8')\n// write file\nexport const write = location => content => fs.writeFileSync(location, content)\n","export const getPublicPathExp = () => /__webpack_require__\\.p\\s?=\\s?([^;]+);/g\nexport const getScriptRegExp = () =>\n  /__webpack_require__\\.p\\s?\\+[^[]+\\[(\\S+)][^\\n]+?\\.js['\"];?/g\nexport const getCssChunksRegExp = () => /var\\scssChunks\\s*=\\s*([^;\\n]+);/\nexport const getCssHrefRegExp = () => /var\\shref\\s*=[^\\n]+?chunkId[^\\n;]+;/\n","import fs from 'fs'\nimport path from 'path'\nexport function isFile(input) {\n  return fs.statSync(input).isFile()\n}\n\nexport function isDir(input) {\n  return fs.statSync(input).isDirectory()\n}\n\nexport function isType(type) {\n  return function enterFile(file) {\n    return isFile(file) && path.extname(file) === '.' + type\n  }\n}\n","export const name = 'webpack-upload-plugin'\n","import { name as pjName } from './static.mjs'\n\n/**\n * log information\n * @param {*} msg\n */\nexport function log(msg) {\n  console.log(`[${pjName}]: ${msg}`)\n}\n\n/**\n * log error\n * @param msg\n */\nexport function logErr(msg) {\n  console.error(`[${pjName}]: ${msg}`)\n}\n","import path from 'path'\nimport fs from 'fs'\nimport fse from 'fs-extra'\nimport { read, write } from './io.mjs'\nimport {\n  getCssChunksRegExp,\n  getCssHrefRegExp,\n  getScriptRegExp,\n  getPublicPathExp\n} from './regexp.mjs'\nimport { isFile, isDir, isType } from './status.mjs'\nimport { logErr } from './log.mjs'\nimport { name as pjName } from './static.mjs'\n\nconst DEFAULT_SEP = '/'\nconst FILTER_OUT_DIR = ['.idea', '.vscode', '.gitignore', 'node_modules']\n\n// 1. gather html file\n// 2. gather production file\n// 3. upload all production file\n// 4. find the usage of production file in html file\n// 5. if found, replace\n\n// type related\nconst imgTypeArr = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'ico']\nconst fontTypeArr = ['woff', 'woff2', 'ttf', 'oft', 'svg', 'eot']\nconst isCss = isType('css')\nconst isJs = isType('js')\nconst isOneOfType = (types = ['']) => file =>\n  types.some(type => isType(type)(file))\n\nfunction isFont(path) {\n  return fontTypeArr.some(type => isType(type)(path))\n}\n\nfunction isImg(path) {\n  return imgTypeArr.some(type => isType(type)(path))\n}\n\n/**\n *\n * @param {string[]} input\n * @return {string}\n */\nfunction resolve(...input) {\n  return path.resolve(...input)\n}\n\n/**\n * @param {string} input\n * @param {string=} [sep=DEFAULT_SEP]\n * @return {string}\n */\nfunction normalize(input, sep = DEFAULT_SEP) {\n  const _input = path.normalize(input)\n  return _input.split(path.sep).join(sep)\n}\n\n/**\n * @param {string} input\n * @return {boolean}\n */\nfunction isFilterOutDir(input) {\n  return FILTER_OUT_DIR.includes(input)\n}\n\n/**\n * remove publicPath from webpack config\n * @param {string} publicPath\n * @return {function(string): string}\n */\nconst handlePublicPath = publicPath => content => {\n  // match strictly\n  const regStr = publicPath\n    .split(DEFAULT_SEP)\n    .filter(item => !!item)\n    .map(part => {\n      if (/\\./.test(part)) {\n        return part.replace(/\\.+/g, match =>\n          match\n            .split('')\n            .map(dot => '\\\\' + dot)\n            .join('')\n        )\n      }\n      return part\n    })\n    .join('\\\\/')\n  const refinedRegStr = `([(=]['\"]?)${regStr}`\n  const reg = new RegExp(refinedRegStr, 'g')\n  return content.replace(reg, (_, prefix) => (prefix ? prefix : ''))\n}\n\n/**\n * given localPath, return string to form matching RegExp\n * @param {string} localPath\n * @returns {string}\n */\nfunction generateLocalPathStr(localPath) {\n  const pathArr = localPath.split(DEFAULT_SEP)\n  const len = pathArr.length\n  return pathArr\n    .map((part, index) => {\n      if (index === len - 1) {\n        return `${part}`\n      } else {\n        return `\\\\.?(${part})?`\n      }\n    })\n    .join(`\\\\${DEFAULT_SEP}?`)\n}\n\n/**\n * produce RegExp to match local path\n * @param {string} localPath\n * @return {RegExp}\n */\nfunction generateLocalPathReg(localPath) {\n  const content = generateLocalPathStr(localPath)\n  const prefix = `([(=+]\\\\s*['\"]?)`\n  // using prefix to strictly match resource reference\n  // like src=\"\", url(\"\"), a = \"\"\n  return new RegExp(`${prefix}${content}`, 'g')\n}\n\n/**\n * find file usage\n * 1. make sure the range: srcPath\n * 2. provide inline path to search and to replace with: localCdnPair\n * @param {string} srcPath\n * @param {string=} distPath\n * @param {function=} replaceFn\n * @param {boolean=} [copyWhenUntouched=true] copy file even if the content remains the same\n * @return {function}\n */\nfunction simpleReplace(\n  srcPath,\n  distPath = srcPath,\n  replaceFn = input => input,\n  copyWhenUntouched = true\n) {\n  const srcFile = read(srcPath)\n  return function savePair(localCdnPair) {\n    const ret = localCdnPair.reduce((last, file) => {\n      const localPath = normalize(file[0])\n      const cdnPath = file[1]\n      const localPathReg = generateLocalPathReg(localPath)\n      last = replaceFn(last, srcPath).replace(\n        localPathReg,\n        (_, prefix) => `${prefix}${cdnPath}`\n      )\n      return last\n    }, srcFile)\n    // no such path > force copy > content change\n    const toCopy =\n      !fs.existsSync(distPath) || copyWhenUntouched || ret !== srcFile\n    if (toCopy) {\n      fse.ensureFileSync(distPath)\n      write(distPath)(ret)\n    }\n  }\n}\n\n/**\n * gather specific file type within directory provided\n * 1. provide range to search: src\n * 2. provide the type of file to search: type\n * @param {string} src: directory to search\n * @return {function}\n */\nfunction gatherFileIn(src) {\n  return function gatherFileType(type) {\n    return fs.readdirSync(src).reduce((last, file) => {\n      const filePath = resolve(src, file)\n      if (isFile(filePath)) {\n        path.extname(file) === `.${type}` && last.push(normalize(filePath))\n      } else if (isFilterOutDir(file)) {\n        // do nothing\n      } else if (isDir(filePath)) {\n        last = last.concat(gatherFileIn(filePath)(type))\n      }\n      return last\n    }, [])\n  }\n}\n\n/**\n * make sure urlCb is applied for all cdn results\n * @param {function(string): string} cb\n * @return {function(string[]|{[string]:string}):[string, string][]}\n */\nconst handleCdnRes = cb => entries => {\n  if (typeof cb !== 'function') return logErr(`urlCb is not function`)\n  const isArr = Array.isArray(entries)\n  // if not array, handle as {[localLocation]: [cdnUrl]}\n  const target = isArr ? entries : Object.entries(entries)\n  return target.map(pair => {\n    // pair[1] should be cdn url\n    // pass local path as well\n    pair[1] = cb(pair[1], pair[0])\n    if (typeof pair[1] !== 'string')\n      logErr(`the return result of urlCb is not string`)\n    return pair\n  })\n}\n\n/**\n * given file path, src root and dist root, return file path in dist root\n * @param {string} srcFilePath\n * @param {string} srcRoot\n * @param {string} distRoot\n * @return {string}\n */\nfunction mapSrcToDist(srcFilePath, srcRoot, distRoot) {\n  return srcFilePath.replace(srcRoot, distRoot)\n}\n\n/**\n * generate {id: name} object for all chunk chunk\n * @param {{id: string, name:string,renderedHash: string, contentHash: string}[]} chunks\n * @param {string} chunkFileName\n */\nfunction gatherChunks(chunks, chunkFileName) {\n  return chunks.reduce((last, chunk) => {\n    if (/\\[hash(:\\d+)?]/.test(chunkFileName)) {\n      throw new Error(\n        `[${pjName}]: Do NOT use [hash] as output filename! Use [chunkhash] or [contenthash] instead`\n      )\n    }\n    const { id, name, renderedHash, contentHash } = chunk\n    // handle slice properly\n    const handleLen = source => (match, len) => {\n      if (len) {\n        return source.slice(0, +len.slice(1))\n      }\n      return source\n    }\n    const handleChunkHash = handleLen(renderedHash)\n    // handle webpack@4 as well as <4\n    const handleContentHash = handleLen(\n      contentHash ? contentHash.javascript : renderedHash\n    )\n    last[id] = chunkFileName\n      .replace(/\\[name]/g, name || `${id}`)\n      .replace(/\\[id]/g, `${id}`)\n      .replace(/\\[chunkhash(:\\d+)?]/g, handleChunkHash)\n      .replace(/\\[contenthash(:\\d+)?]/g, handleContentHash)\n    return last\n  }, {})\n}\n\n/**\n * whether chunk is \"entry\" (common chunks is also considered as \"entry\")\n * @param {string} js\n * @returns {boolean}\n */\nfunction isEntryChunk(js) {\n  const content = read(js)\n  return getScriptRegExp().test(content)\n}\n\n/**\n * convert object to array\n * @param {object} obj\n * @returns {*[]}\n */\nfunction getObjValueArray(obj) {\n  return Object.values(obj)\n}\n\n/**\n * update script.src property for request for dynamic import\n * experimental\n * @param {string[]} files\n * @param {{id: string}} chunkCdnMap\n */\nfunction updateScriptSrc(files, chunkCdnMap) {\n  // if no new map was formed, then keep the way it is\n  const len = Object.keys(chunkCdnMap).length\n  if (!len) return\n  files.forEach(file => {\n    const content = read(file)\n    let newContent = content\n    // update chunkMap\n    if (getScriptRegExp().test(content)) {\n      newContent = newContent.replace(getScriptRegExp(), (match, id) => {\n        if (!id) {\n          return match\n        }\n        return `${JSON.stringify(chunkCdnMap)}[${id}];`\n      })\n    }\n    // update publicPath\n    if (getPublicPathExp().test(content)) {\n      newContent = newContent.replace(\n        getPublicPathExp(),\n        `__webpack_require__.p = \"\";`\n      )\n    }\n    write(file)(newContent)\n  })\n}\n\n/**\n * Handle async CSS files extracted by mini-css-extract-plugin\n * @param {string[]} files\n * @param {[string, string][]} cssMap\n */\nfunction updateCssLoad(files, cssMap) {\n  const keys = cssMap.map(([local]) => local)\n  files.forEach(file => {\n    const content = read(file)\n    let newContent = content\n    const match = content.match(getCssChunksRegExp())\n    if (match) {\n      const [, map] = match\n      newContent = newContent.replace(getCssHrefRegExp(), hrefMatch => {\n        // get the new cssMap with {chunkId, href} structure\n        // where chunkId is the id for the css file, and href is the cdn url\n        const fnBody = `\n            const map = ${map};\n            return Object.keys(map).map(chunkId => {\n              ${hrefMatch};\n              href = href.replace(/^\\\\./, \"\");\n              return {chunkId, href};\n            })\n          `\n        const hrefArr = new Function(fnBody)()\n        // convert to {[chunkId]: href} structure\n        const cssChunkIdCdnMap = hrefArr.reduce((last, { chunkId, href }) => {\n          const localIndex = keys.findIndex(key => key.indexOf(href) > -1)\n          if (localIndex < 0) {\n            return last\n          }\n          last[chunkId] = cssMap[localIndex][1]\n          return last\n        }, {})\n        // cannot form new Map, return the original one\n        if (!Object.keys(cssChunkIdCdnMap).length) {\n          return hrefMatch\n        }\n        const newCssMap = JSON.stringify(cssChunkIdCdnMap)\n        return `var href = ${newCssMap}[chunkId];`\n      })\n      // update js entry file with new cssMap\n      write(file)(newContent)\n    }\n  })\n}\n\n/**\n * get id of chunk given a absolute path of chunk file and id:chunk map\n * @param {string} chunkAbsPath\n * @param {{id: string}} chunkMap\n * @returns {string|number}\n */\nfunction getIdForChunk(chunkAbsPath, chunkMap) {\n  return Object.keys(chunkMap).find(\n    key => chunkAbsPath.indexOf(chunkMap[key]) > -1\n  )\n}\n\n/**\n * make assets object to array with local path\n * @param {{[string]: {existsAt: string}}} asset\n * @returns {string[]}\n */\nfunction getExistsAtFromAsset(asset) {\n  return Object.keys(asset).map(name => {\n    const info = asset[name]\n    return info.existsAt\n  })\n}\n\nexport {\n  resolve,\n  simpleReplace,\n  handlePublicPath,\n  updateScriptSrc,\n  updateCssLoad,\n  isEntryChunk,\n  getIdForChunk,\n  gatherChunks,\n  getObjValueArray,\n  handleCdnRes,\n  mapSrcToDist,\n  gatherFileIn,\n  isJs,\n  isCss,\n  isImg,\n  isFont,\n  isOneOfType,\n  imgTypeArr,\n  fontTypeArr,\n  getExistsAtFromAsset\n}\n","import path from 'path'\nimport {\n  parallel,\n  compatCache,\n  beforeUpload as beforeProcess\n} from 'y-upload-utils'\nimport {\n  resolve,\n  simpleReplace,\n  handlePublicPath,\n  getExistsAtFromAsset,\n  handleCdnRes,\n  isCss,\n  isEntryChunk,\n  isFont,\n  isImg,\n  isJs,\n  isOneOfType,\n  imgTypeArr,\n  fontTypeArr,\n  gatherChunks,\n  gatherFileIn,\n  getIdForChunk,\n  mapSrcToDist,\n  getObjValueArray,\n  updateCssLoad,\n  updateScriptSrc\n} from './util/util.mjs'\nimport { log, logErr } from './util/log.mjs'\n\n/**\n * @typedef {function(string): string} urlCb\n */\n\n/**\n * webpack upload plugin\n * early version need more work\n * @param {{upload: Promise}} cdn\n * custom cdn module, need to have an upload API, return a Promise with structured response\n * like {localPath: cdnPath}\n * @param {object} option\n * @param {string=} option.src\n * @param {string=} option.dist\n * @param {(function(string, string=) => string)=} option.urlCb\n * @param {function=} option.onFinish\n * @param {(function(string, string=) => string)=} option.replaceFn\n * @param {(function(string, string) => string)=} option.beforeUpload\n * @param {(string|string[])=} option.staticDir\n * @param {(function() => Promise<*>)=} option.waitFor\n * @param {boolean=} [option.dirtyCheck=false]\n * @param {boolean=} option.logLocalFiles\n * @param {object=} option.passToCdn\n * @param {boolean=} [option.enableCache=true]\n * @param {string=} option.cacheLocation\n * @param {number=} [option.sliceLimit=10]\n * @param {boolean=} option.forceCopyTemplate\n * @param {boolean=} [option.asyncCSS=true]\n * @param {boolean=} [option.smartAssMode=false]\n * @constructor\n */\nfunction UploadPlugin(cdn, option = {}) {\n  this.cdn = cdn\n  this.option = option\n}\n\nUploadPlugin.prototype.apply = function(compiler) {\n  const self = this\n  const {\n    urlCb = input => input,\n    resolve: resolveList = ['html'],\n    src = '',\n    dist = src,\n    onFinish = () => {},\n    onError = () => {},\n    logLocalFiles: logLocal = false,\n    staticDir = '',\n    replaceFn = input => input,\n    beforeUpload,\n    waitFor = () => Promise.resolve(true),\n    dirtyCheck = false,\n    passToCdn,\n    enableCache = true,\n    cacheLocation,\n    sliceLimit,\n    forceCopyTemplate,\n    asyncCSS = true,\n    smartAssMode = false\n  } = this.option\n  // get absolute path of src and dist directory\n  let srcRoot = resolve(src)\n  let distRoot = resolve(dist)\n  let staticDirMut = staticDir\n  let srcMut = src\n  const getLocal2CdnObj = handleCdnRes(urlCb)\n  const isTemplate = isOneOfType(resolveList)\n\n  /**\n   * update chunkMap to {[id: string|number]: cdnUrl}\n   * @param {{[localPath: string]: string}} chunkPairs\n   * @param {{[id: string|number]: string}} chunkMap\n   * @param {*} start\n   */\n  function generateChunkMapToCDN(chunkPairs, chunkMap, start = {}) {\n    return getLocal2CdnObj(chunkPairs).reduce((last, [localPath, cdnPath]) => {\n      const id = getIdForChunk(localPath, chunkMap)\n      last[id] = cdnPath\n      return last\n    }, start)\n  }\n\n  // wrap a new cdn object\n  const rawCdn = {\n    upload(files) {\n      return self.cdn.upload(files, passToCdn)\n    }\n  }\n\n  // log error for cache setup\n  if (!enableCache && cacheLocation) {\n    logErr(`'cacheLocation' provided while haven't set 'enableCache' to true`)\n    logErr(`This won't enable cache`)\n  }\n\n  // wrap with parallel\n  const paralleledCdn = parallel(rawCdn, { sliceLimit })\n\n  // wrap with cache\n  const wrappedCdn = enableCache\n    ? compatCache(paralleledCdn, {\n        passToCdn,\n        cacheLocation\n      })\n    : paralleledCdn\n\n  // wrap with beforeProcess\n  // use beforeUpload properly\n  const cdn = beforeProcess(wrappedCdn, beforeUpload)\n\n  compiler.plugin('done', async function(stats) {\n    try {\n      // wait to handle extra logic\n      await waitFor()\n      const { chunks, options } = stats.compilation\n      const {\n        output: { publicPath = '', path: outputPath },\n        optimization: { minimize } = {}\n      } = options\n      // early warning\n      if (minimize === true) {\n        log('WARNING! Set the optimization.minimize to false to make it works!')\n      }\n      if (publicPath) {\n        log(\n          'WARNING! publicPath is not empty, the plugin will try to handle it for you. But it is preferred to toggle it by yourself!'\n        )\n      }\n      // try to be smart ass\n      // which means assume all needed files is in the output.path from webpack\n      if (smartAssMode) {\n        srcRoot = outputPath\n        distRoot = outputPath\n        staticDirMut = outputPath\n        srcMut = outputPath\n      }\n      // don't want to use publicPath since about to use cdn url\n      const removePublicPath = handlePublicPath(publicPath)\n      // actual replaceFn that gonna be used\n      const refinedReplaceFn = (content, location) => {\n        const type = path.extname(location)\n        // only remove publicPath occurrence for css/template files\n        // it's tricky to handle js files\n        const removePublicPathTypes = ['.css', ...resolveList.map(t => `.${t}`)]\n        const toRemove = removePublicPathTypes.includes(type)\n        return replaceFn(\n          toRemove ? removePublicPath(content) : content,\n          location\n        )\n      }\n      // if user offers staticDir\n      // then only collect files from staticDir\n      // instead of ones provided by webpack\n      // if pass in an array, gather files recursively\n      const gatherManualAssets = Array.isArray(staticDirMut)\n        ? type => {\n            return staticDirMut.reduce((last, dir) => {\n              return [...last, ...gatherFileIn(dir)(type)]\n            }, [])\n          }\n        : gatherFileIn(staticDirMut)\n      const manualAssets = staticDirMut\n        ? [...imgTypeArr, ...fontTypeArr, 'css', 'js', ...resolveList].reduce(\n            (last, type) => {\n              const files = gatherManualAssets(type)\n              return files.reduce((fileLast, file) => {\n                return Object.assign(fileLast, {\n                  [file]: {\n                    existsAt: file\n                  }\n                })\n              }, last)\n            },\n            {}\n          )\n        : {}\n      // here we get chunks needs to be dealt with\n      const chunkMap = gatherChunks(chunks, options.output.chunkFilename)\n      // all assets including js/css/img\n      const { assets } = staticDirMut\n        ? { assets: manualAssets }\n        : stats.compilation\n      const assetsNames = Object.keys(assets)\n      // classify assets\n      const desireAssets = assetsNames.reduce(\n        (last, name) => {\n          const assetInfo = assets[name]\n          const location = assetInfo.existsAt\n          if (isImg(location)) {\n            last.img[name] = assetInfo\n          } else if (isCss(location)) {\n            last.css[name] = assetInfo\n          } else if (isJs(location)) {\n            last.js[name] = assetInfo\n          } else if (isFont(location)) {\n            last.font[name] = assetInfo\n          } else if (isTemplate(location)) {\n            last.html[name] = assetInfo\n          }\n          return last\n        },\n        {\n          img: {},\n          css: {},\n          js: {},\n          font: {},\n          html: {}\n        }\n      )\n\n      const { img, css, js, font, html } = desireAssets\n\n      // warning if no template found but staticDirMut set\n      if (staticDirMut && !Object.keys(html).length && !src) {\n        log('WARNING!')\n        log(\n          \"staticDir is set but haven't found any template files in those directories\"\n        )\n        log('Try to use src filed to include your template files')\n      }\n\n      const imgArr = getExistsAtFromAsset(img)\n      const fontArr = getExistsAtFromAsset(font)\n      const jsArr = getExistsAtFromAsset(js)\n      const cssArr = getExistsAtFromAsset(css)\n      const htmlArr = getExistsAtFromAsset(html)\n      const chunkArr = getObjValueArray(chunkMap)\n      const commonChunksArr = jsArr.filter(isEntryChunk)\n\n      // find out which js files are chunk chunk, common chunk, or entry\n      const { notChunkJsArr, chunkArrWAbs, commonChunksWAbs } = jsArr.reduce(\n        (last, js) => {\n          const isCommonChunk = commonChunksArr.some(\n            chunk => js.indexOf(chunk) > -1\n          )\n          const isChunk =\n            !isCommonChunk && chunkArr.some(chunk => js.indexOf(chunk) > -1)\n          if (isCommonChunk) {\n            last.commonChunksWAbs.push(js)\n          } else if (isChunk) {\n            last.chunkArrWAbs.push(js)\n          } else {\n            last.notChunkJsArr.push(js)\n          }\n          return last\n        },\n        {\n          notChunkJsArr: [],\n          chunkArrWAbs: [],\n          commonChunksWAbs: []\n        }\n      )\n\n      if (notChunkJsArr.length) {\n        // nothing\n      }\n\n      // upload img/font\n      // find img/font in css\n      // replace css\n      // now css ref to img/font with cdn path\n      // meanwhile upload chunk files to save time\n      log('uploading img and font...')\n      logLocal && console.log([...imgArr, ...fontArr])\n      const imgAndFontPairs = await cdn.upload([...imgArr, ...fontArr])\n      // update img/font reference in css/js files\n      // including chunk files\n      log('update css/js files with new img and font...')\n      const needToUpdateFiles = [...jsArr, ...cssArr]\n      needToUpdateFiles.forEach(location =>\n        simpleReplace(location, location, refinedReplaceFn)(\n          getLocal2CdnObj(imgAndFontPairs)\n        )\n      )\n      // upload chunk files\n      log('uploading chunks...')\n      logLocal && console.log(chunkArrWAbs)\n      const chunkPairs = await cdn.upload(chunkArrWAbs)\n      // update chunkMap, so far no cdn url for common chunks\n      let newChunkMap = generateChunkMapToCDN(chunkPairs, chunkMap, {})\n      log('uploading css...')\n      logLocal && console.log(cssArr)\n      const cssLocal2CdnObj = await cdn.upload(cssArr)\n      if (asyncCSS) {\n        updateCssLoad(commonChunksWAbs, getLocal2CdnObj(cssLocal2CdnObj))\n      }\n      // entry chunk is just entry file : )\n      // the reason uploading common as well as entry is to support webpack@4 and < 4\n      // have common/entry chunks, update chunkMap within it\n      // upload them, so their cdn url can be added to newChunkMap\n      // then entries can be updated with newChunkMap that has cdn url for common chunks\n      let commonChunksPair = {}\n      if (commonChunksWAbs.length) {\n        updateScriptSrc(commonChunksWAbs, newChunkMap)\n        log('upload common/entry chunks...')\n        commonChunksPair = await cdn.upload(commonChunksWAbs)\n        newChunkMap = generateChunkMapToCDN(\n          commonChunksPair,\n          chunkMap,\n          newChunkMap\n        )\n      }\n      // if use dirty check, then check all js files for chunkMap\n      // since webpack@4, every js is chunk\n      // so only filter out common/entry chunks since they should be updated\n      // and uploaded right above\n      const manifestList = dirtyCheck\n        ? jsArr\n        : jsArr.filter(js => !commonChunksWAbs.includes(js))\n      updateScriptSrc(manifestList, newChunkMap)\n\n      // only js here\n      const adjustedFiles = [...manifestList]\n      // if provide with src\n      // then use it\n      // or use emitted html files\n      const tplFiles = !srcMut\n        ? htmlArr\n        : resolveList.reduce((last, type) => {\n            const findFileInRoot = gatherFileIn(srcMut)\n            last = last.concat(findFileInRoot(type))\n            return last\n          }, [])\n\n      log('uploading js...')\n      logLocal && console.log(adjustedFiles)\n      const jsLocal2CdnObj = await cdn.upload(adjustedFiles)\n      // reuse image/common chunks result here\n      // ! important to reuse common chunks since they could just by entry files\n      const allLocal2CdnObj = Object.assign(\n        jsLocal2CdnObj,\n        cssLocal2CdnObj,\n        imgAndFontPairs,\n        commonChunksPair\n      )\n      tplFiles.forEach(filePath => {\n        simpleReplace(\n          filePath,\n          mapSrcToDist(filePath, srcRoot, distRoot),\n          refinedReplaceFn,\n          forceCopyTemplate\n        )(getLocal2CdnObj(allLocal2CdnObj))\n      })\n      // run onFinish if it is a valid function\n      onFinish()\n      log('all done')\n    } catch (e) {\n      log('err occurred!')\n      console.log(e)\n      // run when encounter error\n      onError(e)\n    }\n  })\n}\n\nmodule.exports = UploadPlugin\n"],"names":["const","read","location","fs","readFileSync","write","content","writeFileSync","getPublicPathExp","getScriptRegExp","getCssChunksRegExp","getCssHrefRegExp","isFile","input","statSync","isDir","isDirectory","isType","type","enterFile","file","path","extname","name","log","msg","console","pjName","logErr","error","DEFAULT_SEP","FILTER_OUT_DIR","imgTypeArr","fontTypeArr","isCss","isJs","isOneOfType","types","some","isFont","isImg","resolve","normalize","sep","_input","split","join","isFilterOutDir","includes","handlePublicPath","publicPath","regStr","filter","item","map","part","test","replace","match","dot","refinedRegStr","reg","RegExp","_","prefix","generateLocalPathStr","localPath","pathArr","len","length","index","generateLocalPathReg","simpleReplace","srcPath","distPath","replaceFn","copyWhenUntouched","srcFile","savePair","localCdnPair","ret","reduce","last","cdnPath","localPathReg","toCopy","existsSync","fse","ensureFileSync","gatherFileIn","src","gatherFileType","readdirSync","filePath","push","concat","handleCdnRes","cb","entries","isArr","Array","isArray","target","Object","pair","mapSrcToDist","srcFilePath","srcRoot","distRoot","gatherChunks","chunks","chunkFileName","chunk","Error","renderedHash","contentHash","handleLen","source","slice","handleChunkHash","handleContentHash","javascript","id","isEntryChunk","js","getObjValueArray","obj","values","updateScriptSrc","files","chunkCdnMap","keys","forEach","newContent","JSON","stringify","updateCssLoad","cssMap","local","hrefMatch","fnBody","hrefArr","Function","cssChunkIdCdnMap","href","localIndex","findIndex","key","indexOf","chunkId","newCssMap","getIdForChunk","chunkAbsPath","chunkMap","find","getExistsAtFromAsset","asset","info","existsAt","UploadPlugin","cdn","option","prototype","apply","compiler","self","beforeUpload","Promise","passToCdn","cacheLocation","sliceLimit","forceCopyTemplate","dist","staticDirMut","staticDir","srcMut","getLocal2CdnObj","urlCb","isTemplate","resolveList","generateChunkMapToCDN","chunkPairs","start","rawCdn","upload","enableCache","paralleledCdn","parallel","wrappedCdn","compatCache","beforeProcess","plugin","stats","waitFor","compilation","options","outputPath","minimize","smartAssMode","removePublicPath","refinedReplaceFn","removePublicPathTypes","t","toRemove","gatherManualAssets","dir","manualAssets","fileLast","assign","output","chunkFilename","assets","assetsNames","desireAssets","assetInfo","img","css","font","html","imgArr","fontArr","jsArr","cssArr","htmlArr","chunkArr","commonChunksArr","isCommonChunk","isChunk","commonChunksWAbs","chunkArrWAbs","notChunkJsArr","logLocal","imgAndFontPairs","needToUpdateFiles","newChunkMap","cssLocal2CdnObj","manifestList","dirtyCheck","adjustedFiles","tplFiles","findFileInRoot","jsLocal2CdnObj","allLocal2CdnObj","commonChunksPair","onFinish","asyncCSS","e","onError","module","exports"],"mappings":"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"}